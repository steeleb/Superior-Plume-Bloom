---
title: "Check eePlumB labels for consistency"
author: "ROSSyndicate"
date: "2024-03-22"
output: html_document
---

```{r setup, echo = F}
# keep things quiet
knitr::opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE)

# get all the functions from the src folder and load them
source_files <- list.files("src", full.names = T)
invisible(lapply(source_files, source))
# and the funcs for this analysis
analysis_funcs <- list.files("modeling/src", full.names = T)
invisible(lapply(analysis_funcs, source))
# list/load/download the packages needed for this script
packages <- c('rstatix',
              'tidyverse',
              'ggthemes')
invisible(lapply(packages, package_loader))
```

# Purpose

This script looks through the eePlumB labels to check for inconsistencies between
the user-exported data and the re-pull of data. It also removes/flags any labels that 
may be contaminated with cirrus clouds.

## Load data

Read in the label data:

```{r}
collated_data <- read_csv("data/labels/collated_labels_with_additional_data_v2024-03-07.csv")
# overlapping bands between original pull and new pull
LS57_bands_over <- c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7")
LS89_bands_over <- c("SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7")
S2_bands_over <-c("SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B6", "SR_B8", "SR_B11", "SR_B12")
# and all SR bands that we care about for GTB
LS57_bands <- c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7", "ST_B6")
LS89_bands <- c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7", "ST_B10")
S2_bands <- c("SR_B1","SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B6", "SR_B8", "SR_B8A", "SR_B9", "SR_B11", "SR_B12")
```

And the scene-level metadata:

```{r}
metadata <- read_csv("data/labels/collated_scene_metadata_v2024-03-07.csv") %>% 
  mutate(mission = if_else(!is.na(SPACECRAFT_NAME),
                           SPACECRAFT_NAME,
                           SPACECRAFT_ID),
         date = if_else(grepl("LAND", mission),
                        ymd(str_sub(`system:id`, -8, nchar(`system:id`))),
                        ymd(str_sub(`system:id`, -22, -15)))) 
metadata_less <- metadata %>% 
  group_by(mission, date) %>% 
  summarise(CLOUD_COVER_max = max(CLOUD_COVER),
            CLOUD_COVER_min = min(CLOUD_COVER),
            CLOUD_COVER = mean(CLOUD_COVER),
            GEOMETRIC_QUALITY = paste(na.omit(GEOMETRIC_QUALITY), collapse = "; "),
            GENERAL_QUALITY = paste(na.omit(GENERAL_QUALITY), collapse = "; "),
            CLOUDY_PIXEL_PERCENTAGE_max = max(CLOUDY_PIXEL_PERCENTAGE),
            CLOUDY_PIXEL_PERCENTAGE_min = min(CLOUDY_PIXEL_PERCENTAGE),
            CLOUDY_PIXEL_PERCENTAGE = mean(CLOUDY_PIXEL_PERCENTAGE),
            CLOUD_COVERAGE_ASSESSMENT = mean(CLOUD_COVERAGE_ASSESSMENT),
            CLOUD_SHADOW_PERCENTAGE_max = max(CLOUD_SHADOW_PERCENTAGE),
            CLOUD_SHADOW_PERCENTAGE_min = min(CLOUD_SHADOW_PERCENTAGE),
            CLOUD_SHADOW_PERCENTAGE = mean(CLOUD_SHADOW_PERCENTAGE),
            HIGH_PROBA_CLOUDS_PERCENTAGE = mean(HIGH_PROBA_CLOUDS_PERCENTAGE),
            MEDIUM_PROBA_CLOUDS_PERCENTAGE = mean(MEDIUM_PROBA_CLOUDS_PERCENTAGE),
            THIN_CIRRUS_PERCENTAGE = mean(THIN_CIRRUS_PERCENTAGE),
            SNOW_ICE_PERCENTAGE = mean(SNOW_ICE_PERCENTAGE),
            DATA_SOURCE_REANALYSIS = paste(na.omit(DATA_SOURCE_REANALYSIS), collapse = "; "),
            DATA_SOURCE_WATER_VAPOR = paste(na.omit(DATA_SOURCE_WATER_VAPOR), collapse = "; "),
            IMAGE_QUALITY = paste(na.omit(IMAGE_QUALITY), collapse = "; "),
            IMAGE_QUALITY_OLI = paste(na.omit(IMAGE_QUALITY_OLI), collapse = "; "), 
            AOT_RETRIEVAL_ACCURACY = paste(na.omit(AOT_RETRIEVAL_ACCURACY), collapse = "; "),
            AOT_RETRIEVAL_METHOD = paste(na.omit(AOT_RETRIEVAL_METHOD), collapse = "; "),
            GRANULE_MEAN_AOT = mean(GRANULE_MEAN_AOT)
            )
  

left_join(collated_data, metadata_less)
```


These data will need some wrangling. The column labels are not in an intuitive order,
and there is a mix of Sen2 and LS columns in each satellite group.

### Landsat 5/7

```{r}
LS5 <- collated_data %>% 
  filter(mission == "LS5") %>% 
  select(date, mission, class, vol_init, 
         # rename these for comparison's sake, these were re-named in the js code
         B1 = Blue, 
         B2 = Green, 
         B3 = Red, 
         B4 = B5, 
         B5 = B6, 
         B7, 
         # re-pull columns
         starts_with("SR"), starts_with("ST"), contains("QA"), 
         # drop ls8/9 temp band
         -c(ST_B10, cirrus, opaque_cloud),
         # drop sen/ls89 columns
         -c(SR_B6, SR_B8, SR_B8A, SR_B9, SR_B11, SR_B12, QA10, QA20, QA60),
         # drop ls89 qa column
         -contains("AERO")) %>% 
  mutate(across(c(B1:SR_B7),
                ~ round(., digits = 5)))

LS7 <- collated_data %>% 
  filter(mission == "LS7") %>% 
  select(date, mission, class, vol_init, 
         # rename these for comparison's sake, these were re-named in the js code
         B1 = Blue, 
         B2 = Green, 
         B3 = Red, 
         B4 = B5, 
         B5 = B6, 
         B7, 
         # re-pull columns
         starts_with("SR"), starts_with("ST"), contains("QA"), 
         # drop ls8/9 temp band
         -c(ST_B10, cirrus, opaque_cloud),
         # drop sen/ls89 columns
         -c(SR_B6, SR_B8, SR_B8A, SR_B9, SR_B11, SR_B12, QA10, QA20, QA60),
         # drop ls89 qa column
         -contains("AERO")) %>% 
  mutate(across(c(B1:SR_B7),
                ~ round(., digits = 5)))
```


### Landsat 8/9

```{r}
LS8 <- collated_data %>% 
  filter(mission == "LS8") %>% 
  select(date, mission, class, vol_init, 
         # rename these for comparison's sake, these were re-named in the js code
         B2 = Blue, 
         B3 = Green, 
         B4 = Red, 
         B5, 
         B6, 
         # re-pull columns
         starts_with("SR"), starts_with("ST"), contains("conf"), starts_with("QA"),
         # drop ls5/7 band
         -c(ST_B6, SR_ATMOS_OPACITY, SR_CLOUD_QA),
         # drop sen columns
         -c(SR_B8, SR_B8A, SR_B9, SR_B11, SR_B12, QA10, QA20, QA60)) %>% 
  mutate(across(c(B2:SR_B7),
                ~ round(., digits = 5)))

LS9 <- collated_data %>% 
  filter(mission == "LS9") %>% 
  select(date, mission, class, vol_init, 
         # rename these for comparison's sake, these were re-named in the js code
         B2 = Blue, 
         B3 = Green, 
         B4 = Red, 
         B5, 
         B6, 
         # re-pull columns
         starts_with("SR"), starts_with("ST"), contains("conf"), starts_with("QA"),
         # drop ls5/7 band
         -c(ST_B6, SR_ATMOS_OPACITY, SR_CLOUD_QA),
         # drop sen columns
         -c(SR_B8, SR_B8A, SR_B9, SR_B11, SR_B12, QA10, QA20, QA60)) %>% 
  mutate(across(c(B2:SR_B7),
                ~ round(., digits = 5)))


```


### Sentinel 2

```{r}
S2 <- collated_data %>% 
  filter(mission == "SEN2") %>% 
  select(date, mission, class, vol_init, 
         # rename these for comparison's sake, these were re-named in the js code
         B2 = Blue, 
         B3 = Green, 
         B4 = Red, 
         B5, B6, B8, B11, B12,
         # re-pull columns
         starts_with("SR"), 
         cirrus, opaque_cloud, starts_with("QA"), 
         starts_with("MSK"),
         # drop landsat bands
         -c(starts_with("ST"), contains("conf"), contains("AERO"),
            SR_ATMOS_OPACITY, SR_CLOUD_QA, QA_RADSAT, QA_PIXEL))

```


## Convert Binary columns

### Landsat 5 QA bits

```{r}
LS5 <- LS5 %>% 
  mutate(across(c(SR_CLOUD_QA, QA_PIXEL),
                ~ R.utils::intToBin(.),
                .names = "{.col}_binary")) %>% 
  mutate(snow_ice_conf = case_when(str_sub(QA_PIXEL_binary, start = 1, end = 2) == "00" ~ "none",
                            str_sub(QA_PIXEL_binary, start = 1, end = 2) == "01" ~ "low",
                            str_sub(QA_PIXEL_binary, start = 1, end = 2) == "10" ~ "reserved",
                            str_sub(QA_PIXEL_binary, start = 1, end = 2) == "11" ~ "high"),
         cloud_shad_conf = case_when(str_sub(QA_PIXEL_binary, start = 3, end = 4) == "00" ~ "none",
                            str_sub(QA_PIXEL_binary, start = 3, end = 4) == "01" ~ "low",
                            str_sub(QA_PIXEL_binary, start = 3, end = 4) == "10" ~ "reserved",
                            str_sub(QA_PIXEL_binary, start = 3, end = 4) == "11" ~ "high"),
         cloud_conf = case_when(str_sub(QA_PIXEL_binary, start = 5, end = 6) == "00" ~ "none",
                            str_sub(QA_PIXEL_binary, start = 5, end = 6) == "01" ~ "low",
                            str_sub(QA_PIXEL_binary, start = 5, end = 6) == "10" ~ "med",
                            str_sub(QA_PIXEL_binary, start = 5, end = 6) == "11" ~ "high"),
         snow = if_else(str_sub(QA_PIXEL_binary, start = 9, end = 9) == "1",
                        1,
                        0),
         cloud_shad = if_else(str_sub(QA_PIXEL_binary, start = 10, end = 10) == "1",
                        1,
                        0),
         cloud = if_else(str_sub(QA_PIXEL_binary, start = 11, end = 11) == "1",
                        1,
                        0),
         dil_cloud = if_else(str_sub(QA_PIXEL_binary, start = 12, end = 12) == "1",
                        1,
                        0)
         )

```

## Landsat 5 SR bands

Just look at the data to see 'how bad' the consistency is between the user-pulled
data and our pull:

```{r, echo=FALSE}
pmap(.l = list(user_band = c("B1", "B2", "B3", "B4", "B5", "B7"),
               ee_band = LS57_bands,
               data = list(LS5),
               data_name = list("Landsat 5")),
     .f = make_band_comp_plot)
```

Look at the data that don't match, in this case, we'll just use B7 as a reference

```{r}
LS5_inconsistent <- LS5 %>% 
  filter(is.na(SR_B7) | 
           SR_B7 != B7)
```

Most of these are cloud labels, where the pixel is saturated, and then masked in 
the ee value - we can keep these as training data as long as the values match. Let's drop those from this subset and then look more.

```{r}
LS5_inconsistent <- LS5_inconsistent %>% 
  filter(!(class == "cloud" & is.na(SR_B7))) 
```

This leaves ~`r round(nrow(LS5_inconsistent)/nrow(LS5))*100, 1)` of the Landsat 
5 labels as inconsistent and shouldn't be included in the test/train set. 
Since we're not going to classify saturated pixels, we'll drop those 
too (these are instances where the pull we did will be NA but the user pull will 
have a value). Let's do a quick sanity check to make sure that we've dropped 
values that are inconsistent between pulls:

```{r}
LS5_filtered <- LS5 %>% 
  # filter data where SR_B7 has data and where the values match between the two
  # pulls.
  filter((!is.na(SR_B7) & SR_B7 == B7 ) | 
           # or where the user-specified class is cloud and the pixel was saturated
           # providing no surface refelctance data
           (class == "cloud" & is.na(SR_B7))) %>% 
  filter(# or where any band value is greater than 1
           if_all(LS57_bands,
                  ~ . <= 1)) %>% 
  filter(complete.cases(.))
```

```{r, echo=FALSE}
pmap(.l = list(user_band = c("B1", "B2", "B3", "B4", "B5", "B7"),
               ee_band = c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7"),
               data = list(LS5_filtered),
               data_name = list("Landsat 5")),
     .f = make_band_comp_plot)
```

And now let's look at the data by class:

```{r, echo=FALSE}
pmap(.l = list(data = list(LS5_filtered),
               data_name = list("Landsat_5"),
               band = LS57_bands),
     .f = make_class_comp_plot)
```

We aren't actually modeling "other" or "shoreline contamination", so let's drop
those.

```{r}
LS5_class_analysis <- LS5_filtered %>% 
  filter(!(class %in% c("other", "shorelineContamination")))
```

```{r, echo=FALSE}
pmap(.l = list(data = list(LS5_class_analysis),
               data_name = list("Landsat_5"),
               band = LS57_bands),
     .f = make_class_comp_plot)
```

### Outlier handling

There are definitely outliers here and they may impact the interpretation of any
statistical testing we do.

```{r}
vertical_data <- LS5_class_analysis %>% 
  pivot_longer(LS57_bands,
             names_to = "band_name",
             values_to = "value") %>% 
  rowid_to_column()
outliers <- vertical_data %>% 
  group_by(class, band_name) %>% 
  identify_outliers(., value) %>% 
  filter(is.extreme) %>% 
  select(class:value) %>% 
  left_join(vertical_data) %>%
  select(-rowid) %>% 
  pivot_wider(names_from = band_name,
              values_from = value,
              values_fn = max)
```


### Testing for inter-class differences

In order to test for differences via ANOVA we need to know if the data are normally 
distributed. So shapiro-wilkes first to test for normality!   

```{r}
LS57_band_sym = syms(LS57_bands)

pmap(.l = list(dataset = list(LS5_class_analysis),
               band = LS57_band_sym),
     .f = test_class_sig)
        
```


## Landast 7 SR bands

Just look at the data to see 'how bad' the consistency is between the user-pulled
data and our pull:

```{r}
pmap(.l = list(user_band = c("B1", "B2", "B3", "B4", "B5", "B7"),
               ee_band = c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7"),
               data = list(LS7),
               data_name = list("Landsat 7")),
     .f = make_band_comp_plot)
```

Look at the data that don't match, in this case, we'll just use B1 as a reference

```{r}
LS7_inconsistent <- LS7 %>% 
  filter(is.na(SR_B1) | 
           SR_B1 != B1)
```

```{r}
LS7_inconsistent <- LS7_inconsistent %>% 
  filter(!(class == "cloud" & is.na(SR_B1)))

```

The number of LS7 
labels being dropped is pretty high - so we might want to dig a bit more into 
that. 

Looking at the data frame for LS7 inconsistencies, it's clear there is at least
one image-date that should be excluded from this dataset, as most of the labels
do not match - 2020-07-18 by BJM. No other date/labelers seem to be consistently
mis-matched - this date accounts for more than half of the inconsistencies:

```{r}
LS7_inconsistent %>% 
  filter(date == "2020-07-18", vol_init == "BJM") %>% 
  nrow(.)
```


```{r}
LS7_filtered <- LS7 %>% 
  # filter data where SR_B1 has data and where the values match between the two
  # pulls and the SR values are less than or equal to 1
  filter((!is.na(SR_B1) & SR_B1 == B1 & SR_B1 <= 1) | 
           # or where the user-specified class is cloud and the pixel was saturated
           # providing no surface refelctance data
           (class == "cloud" & is.na(SR_B1))) %>% 
  # filter out the problematic date/init
  filter(!(date == "2020-07-18" & vol_init == "BJM")) 
pmap(.l = list(user_band = c("B1", "B2", "B3", "B4", "B5", "B7"),
               ee_band = c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7"),
               data = list(LS7_filtered),
               data_name = list("Landsat 7")),
     .f = make_band_comp_plot)
```

```{r}

pmap(.l = list(data = list(LS7_filtered),
               data_name = list("Landsat_7"),
               band = c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7")),
     .f = make_class_comp_plot)


```


```{r}
LS7_class_analysis <- LS7_filtered %>% 
  filter(!(class %in% c("other", "shorelineContamination")))
pmap(.l = list(data = list(LS7_class_analysis),
               data_name = list("Landsat_7"),
               band = c("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B7")),
     .f = make_class_comp_plot)
```

